% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/selpPredict.R
\name{selpscca.pred}
\alias{selpscca.pred}
\title{2-step supervised SELPCCA}
\usage{
selpscca.pred(
  Xdata1,
  Xdata2,
  Y,
  fitselpCCA = NULL,
  family = "gaussian",
  event = NULL,
  model.separately = FALSE,
  ncancorr = 1,
  CovStructure = "Iden",
  isParallel = TRUE,
  ncores = NULL,
  nfolds = 5,
  ngrid = 10,
  standardize = TRUE,
  thresh = 1e-04,
  maxiteration = 20,
  showProgress = T
)
}
\arguments{
\item{Xdata1}{A matrix of size n × p for first dataset. Rows are
samples and columns are variables.}

\item{Xdata2}{A matrix of size n × q for second dataset. Rows are
samples and columns are variables.}

\item{Y}{A vector of size n for the outcome. Continuous outcomes
do not have to be centered or scaled. If family="survival",
Y is a vector of size n indicating the time at which
the event occurred or the observation was censored. See
'event' for more information on how to use function for
a survival outcome.}

\item{fitselpCCA}{The output of cvselpscca() function or multiplescca(). If
NULL, the algorithm will fit a cvselpscca model.}

\item{family}{A string to denote the type of prediction model to build.
Options are "gaussian", "binomial", "poisson", or "survival".
When family="survival", a proportional Cox model will be fitted.
Otherwise a generalized linear model will be used.}

\item{event}{A vector of size n needed when family="survival" to denote whether
or not the event of interest occurred at timepoint Y. Let
event=NULL when family does not equal "survival".}

\item{model.separately}{A boolean to denote whether or not to use separate
prediction models for Xdata1 and Xdata2. When
model.separately=FALSE, a single model will be fit using
the output for both datasets.}

\item{ncancorr}{Number of canonical correlation vectors. Default is 1.}

\item{CovStructure}{Covariance structure to use in estimating sparse
canonical correlation vectors. Either "Iden" or "Ridge".
Iden assumes the covariance matrix for each dataset
is identity. Ridge uses the sample covariance for each
dataset. See reference article for more details.}

\item{isParallel}{TRUE or FALSE for parallel computing. Default is TRUE.}

\item{ncores}{Number of cores to be used for parallel computing. Only
used if isParallel=TRUE. If isParallel=TRUE and ncores=NULL,
defaults to half the size of the number of system cores.}

\item{nfolds}{Number of cross validation folds. Default is 5.}

\item{ngrid}{Number of grid points for tuning parameters. Default
is 10 for each dataset.}

\item{standardize}{TRUE or FALSE. If TRUE, data will be normalized to
have mean zero and variance one for each variable. Note
that this only standardizes Xdata1 and Xdata2. Y will not
be standardized. Default is TRUE.}

\item{thresh}{Threshold for convergence. Default is 0.0001.}

\item{maxiteration}{Maximum iteration for the algorithm if not converged.
Default is 20.}

\item{showProgress}{A boolean for whether or not the function
should display text output at various stages in
the function to indicate progress. Default is TRUE.}
}
\value{
The output is a list containing the following components.
\item{selp.fit}{The output of the cvselpscca() function.}
\item{mod.fit}{The output of the glm() or coxph() regression model.}
\item{data.matrix}{The data matrix that was used to build the regression model.}
\item{family}{The type of outcome specified.}
}
\description{
Performs n-fold cross validation to select optimal
tuning parameters for SELPCCA based on training data. Then uses the
results to build a GLM or survival model for a pre-specified outcome.
}
\details{
The function will return several R objects, which can be assigned
 to a variable. To see the results, use the “$" operator.
}
\examples{
\dontrun{
##---- read in data
data(sidaData)

Xdata1=sidaData[[1]][[1]]
Xdata2=sidaData[[1]][[2]]
Y=sidaData[[2]]-1

myresult=selpscca.pred(Xdata1, Xdata2, Y,fitselpCCA=NULL, family="binomial",
             event=NULL,model.separately=FALSE, ncancorr=1,
             CovStructure="Iden", isParallel=FALSE, ncores=NULL,
             nfolds=5, ngrid=10, standardize=TRUE,thresh=0.0001,
             maxiteration=20, showProgress=T)

#check output
train.correlation=myresult$selp.fit$maxcorr
optTau=myresult$selp.fit$optTau
hatalpha=myresult$selp.fit$hatalpha
hatbeta=myresult$selp.fit$hatbeta
predictionModel=summary(myresult$mod.fit)

##Performance metrics
##Train Performance Metrics
newPredictions=predict(myresult, newdata=Xdata1, newdata2=Xdata2, type="response")
Y.pred=newPredictions$pred.mod #predicted probabilities
Y.train=Y
train.metrics=PerformanceMetrics(Y.pred,Y.train,family='binomial',isPlot=TRUE)
print(train.metrics)

##Test Performance Metrics
Y.test=sidaData[[4]]-1
newPredictions=predict(myresult, newdata=Xtestdata1, newdata2=Xtestdata2, type="response")
Y.pred=newPredictions$pred.mod #predicted probabilities
test.metrics=PerformanceMetrics(Y.pred,Y.test,family='binomial',isPlot=TRUE)
print(test.metrics)
}
}
\references{
Sandra E. Safo, Jeongyoun Ahn, Yongho Jeon, and Sungkyu Jung (2018),
 Sparse Generalized Eigenvalue Problem with Application to Canonical
 Correlation Analysis for Integrative Analysis of Methylation and Gene
 Expression Data. Biometrics
}
\seealso{
\code{\link{cvselpscca}}
}
